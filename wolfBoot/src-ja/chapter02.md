

# wolfBootのビルド



wolfBootは、さまざまな種類の組み込みシステムにわたってポータブルです。プラットフォーム固有のコードは、`hal`ディレクトリの下にある単一のファイルに含まれており、ハードウェア固有の機能を実装します。


特定のコンパイルオプションを有効にするには、makeコマンドと共に環境変数を使用します。


`make CORTEX_M0=1`


別の方法として、wolfBootのルートディレクトリに.configファイルを提供できます。`?=`オペレーターを使用して定義されている限り、コマンドラインオプションは`.config`オプションで優先されます。


`WOLFBOOT_PARTITION_BOOT_ADDRESS?=0x14000`



## コンフィギュレーションファイルの新規作成



デフォルトパラメーターのセットを備えた新しい`.config`ファイルは、`make config`を実行することで生成できます。ビルドスクリプトは、各構成パラメーターのデフォルト値を入力するように要求してきます。`[]`の間に示されている現在の値を確認します。


.configファイルが設置されると、パラメーターなしで`make`を実行すると、デフォルトのコンパイル時オプションが変更されます。


.configは、テキストエディターで変更して、後でデフォルトのオプションを変更できます。


使用可能なコンフィギュレーションオプションの詳細については、[付録N コンフィギュレーションオプション](appendix14.md)に掲載しています。


## プラットフォームの選択



ネイティブにサポートされている場合、ターゲットプラットフォームは`TARGET`変数を使用して指定できます。Makeは、正しいコンパイルオプションを自動的に選択し、選択したターゲットに対応するHALを含めます。


現在サポートされているプラットフォームのリストについては、[HAL](chapter04.md#hardware-abstraction-layer)の章を参照してください。


新しいプラットフォームを追加するには、`hal`ディレクトリに対応するHALドライバーとリンカースクリプトファイルを作成するだけです。


指定されていない場合のデフォルトオプション：`TARGET=stm32f4`


一部のプラットフォームには、アーキテクチャに固有の追加オプションが必要です。デフォルトでは、wolfBootはARM Cortex-M3/4/7用にコンパイルされています。cortex-m0をコンパイルするには、次を使用します。


`CORTEX_M0=1`



### フラッシュパーティション



ファイル`include/target.h`は、構成されたフラッシュジオメトリ、パーティションサイズ、ターゲットシステムのオフセットに従って生成されます。次の値を、コマンドラインを介して、または.configファイルを使用して、目的のフラッシュ構成を提供するように設定する必要があります。


 - `WOLFBOOT_SECTOR_SIZE` 


この変数は、フラッシュメモリ上の物理セクターのサイズを決定します。ブロックサイズが異なる領域が2つのパーティションに使用されている場合(たとえば、外部フラッシュでパーティションを更新する)、この変数は2つのパーティション間で共有される最大のセクターのサイズを示す必要があります。


wolfBootは、ファームウェアイメージを所定の位置に交換するときに、この値を最小ユニットとして使用します。このため、この値はスワップパーティションのサイズを設定するためにも使用されます。


 - `WOLFBOOT_PARTITION_BOOT_ADDRESS`


これは、新しいフラッシュセクターの開始に合わせたブートパーティションの開始アドレスです。アプリケーションコードは、パーティションヘッダーサイズ(ED25519の場合は256BおよびECC署名ヘッダー)に等しく、さらにオフセットされた後に開始されます。


 - `WOLFBOOT_PARTITION_UPDATE_ADDRESS`


これは、更新パーティションの開始アドレスです。`EXT_FLASH`オプションを介して外部メモリを使用する場合、この変数には、外部メモリアドレス指定可能なスペースの先頭からの更新パーティションのオフセットが含まれます。


 - `WOLFBOOT_PARTITION_SWAP_ADDRESS`


wolfBootで使用されているスワップ間隔のアドレスは、反転可能な更新を実行するために、2つのファームウェアイメージを所定の位置に交換します。スワップパーティションのサイズは、フラッシュ上のまったく1つのセクターです。外部メモリが使用される場合、変数にはアドレス指定可能なスペースの先頭からスワップ領域のオフセットが含まれます。


 - `WOLFBOOT_PARTITION_SIZE`


ブートと更新パーティションのサイズ。サイズは両方のパーティションで同じです。



## ブートローダー機能



wolfBootコンピレーション中に、多くの特性をオン/オフにすることができます。ブートローダーのサイズ、パフォーマンス、アクティブ化された機能は、コンパイル時間フラグの影響を受けます。



### DSAアルゴリズムの変更



デフォルトでは、wolfBootはED25519 DSAを使用するようにコンパイルされています。ED25519の実装は小さく、ブートアップ時間の観点からは良い妥協点を与えます。


curve P-256のECDSAを使用すると、パフォーマンスを向上できます。ECC256サポートを有効にするには、makeコマンドに以下のオプションを指定してください：


`SIGN=ECC256`




RSAでも異なる鍵長に変更できます。RSA2048またはRSA4096をアクティブにするには、それぞれ以下を指定します：


`SIGN=RSA2048`


あるいは


`SIGN=RSA4096`





ED448は`SIGN=ED448`でサポートされています。


`SIGN`変数の値が提供されていない場合、デフォルトオプションは以下の値です。


`SIGN=ED25519`


DSAアルゴリズムを変更すると、鍵生成とファームウェアの署名のために異なるツールセットをコンパイルします。


`tools`ディレクトリに、対応する鍵生成およびファームウェア署名ツールが格納されています。


以下を明示的に使用して、ファームウェアイメージの認証を無効にすることができます。


`SIGN=NONE`


これにより、パブリック鍵認証セキュアーブートをサポートせずに最小限のブートローダーをコンパイルします。



### インクリメンタル更新



wolfBootはインクリメンタル更新をサポートしています。この機能を有効にするには、`DELTA_UPDATES=1`でコンパイルします。


署名ツールが`--delta`オプションで呼び出されたときに追加ファイルが生成されます。これは、現在ターゲットで実行されている古いファームウェアの違いのみを含み、新しいバージョンで実行されます。


詳細と例については、[ファームウェアの更新](chapter06.md#firmware-update)セクションを参照してください。



### デバッグシンボルの有効化



ブートローダーをデバッグするには、`DEBUG=1`でコンパイルするだけです。ですがブートロードのサイズは一貫して増加します。そのため、`WOLFBOOT_PARTITION_BOOT_ADDRESS`の前にフラッシュの開始時に十分なスペースがあることを確認してください。



### 割り込みベクトルの再配置の無効化



一部のプラットフォームでは、起動する前に割り込みベクトルの再配置を回避するのが便利かもしれません。これは、システム上のコンポーネントが別の段階で割り込み再配置を既に管理している場合、または割り込みベクターの再配置をサポートしないこれらのプラットフォームで既に管理している場合に必要です。


割り込みベクトルテーブルの再配置を無効にするには、`VTOR=0`でコンパイルします。デフォルトでは、wolfBootはベクトル再配置オフセットレジスタ(VTOR)にオフセットを設定して割り込みベクターを再配置します。



### スタック使用の制限



デフォルトでは、wolfBootはメモリの割り当てを必要としません。スタックを使用してすべての操作を実行しています。アルゴリズムで使用されるスタックスペースはコンパイル時間で予測できますが、選択したアルゴリズムに応じて、スタックスペースの量は比較的大きくなります。


一部のターゲットは、一般的に、またはブートローダーステージ専用の構成で、スタックスペースとして使用する限られた量のRAMを提供します。


これらの場合、`WOLFBOOT_SMALL_STACK=1`をアクティブにすると便利な場合があります。このオプションを使用すると、コンパイル時に固定サイズのプールが作成され、暗号化の実装に必要なオブジェクトの割り当てを支援します。`WOLFBOOT_SMALL_STACK=1`でコンパイルされると、wolfBootはスタックの使用量を大幅に削減し、専用の静的に割り当てられた事前サイズのメモリ領域を割り当てることにより、動的メモリ割り当てをシミュレートします。



### 現在実行中ファームウェアのバックアップ無効化



オプションで、アップデートのインストール時に現在の実行中のファームウェアのバックアップコピーを無効にすることができます。これは、フォールバックメカニズムが誤ったファームウェアのインストールからターゲットを保護していないことを意味しますが、ブートローダーから更新パーティションに書き込むことができない場合には役立つ場合があります。関連するコンパイル時間オプションはです


`DISABLE_BACKUP=1`



### 「ライトワンス」フラッシュメモリの回避策の有効化



一部のマイクロコントローラーでは、内部フラッシュメモリは、セクター全体が消去された後、セクターに追加の書き込み(ゼロを追加)を許可しません。wolfBootは、両方のパーティションの最後にある「フラグ」フィールドにゼロを追加するメカニズムに依存して、フェイルセーフスワップメカニズムを提供します。


「ライトワンス」内部フラッシュの回避策を有効にするには、


`NVM_FLASH_WRITEONCE=1`


**警告**このオプションが有効になっている場合、フェールセーフスワップは保証されません。つまり、マイクロコントローラーをSWAP操作中に安全に電源を入れたり再起動したりすることはできません。



### バージョンロールバックの許可



wolfBootは、現在のものよりも小さいバージョン番号があるファームウェアの更新を許可しません。ダウングレードを許可するには、`ALLOW_DOWNGRADE=1`でコンパイルします。


警告：このオプションは、更新前にバージョンチェックを無効にし、システムを潜在的な強制ダウングレード攻撃の危険性にさらすことになります。



### 外部フラッシュメモリのオプションのサポートを有効にします



wolfBootはMakeFileオプション`EXT_FLASH=1`でコンパイルできます。外部フラッシュサポートが有効になっている場合、パーティションを更新およびスワップすることが外部メモリに関連付けられ、読み取り/書き込み/消去アクセスに代替HAL機能を使用します。更新またはスワップパーティションを外部メモリに関連付けるには、それぞれ`PART_UPDATE_EXT`および/または`PART_SWAP_EXT`を定義します。デフォルトでは、MakeFileは、外部メモリが存在する場合、`PART_UPDATE_EXT`と`PART_SWAP_EXT`の両方が定義されていると想定しています。


`NO_XIP=1` MakeFileオプションが存在する場合、システムで実行されない場所がないため、`PART_BOOT_EXT`も想定されています。これは通常、MMUシステム(ARM Cortex-Aなど)の場合です。オペレーティングシステムのイメージは、実行不可能な不揮発性メモリに保存されている位置に依存しないELFイメージであり、検証後に起動するためにRAMでコピーする必要があります。


外部メモリを使用する場合、HAL APIを拡張して、カスタムメモリにアクセスするメソッドを定義する必要があります。`ext_flash_*` APIの説明については、[HAL](chapter04.md#hardware-abstraction-layer)の章を参照してください。



#### SPIデバイス



`EXT_FLASH=1`構成パラメーターと組み合わせて、プラットフォーム固有のSPIドライバーを使用することができます。外部SPIフラッシュメモリにアクセスします。MakeFileオプション`SPI_FLASH=1`でwolfBootをコンパイルすることにより、外部メモリは追加のSPIレイヤーに直接マッピングされるため、ユーザーは`ext_flash_*`関数を定義する必要はありません。


代わりに、SPI関数を定義する必要があります。SPIドライバーの例は、`hal/spi`ディレクトリの複数のプラットフォームで利用できます。



#### 隣接システムとの間でUARTブリッジを使用



外部デバイスをマップするために利用できるもう1つの代替手段は、隣接システムにUARTブリッジを有効にするです。近隣システムは、wolfBootプロトコルと互換性のあるUARTインターフェースを介してサービスを公開する必要があります。


SPIデバイスの場合と同じように、`UART_FLASH=1`が使用される場合、`ext_flash_*` APIはwolfBootによって自動的に定義されます。


詳細については、セクション[UART経由のリモート外部フラッシュメモリサポート](chapter06.md#remote-external-flash-memory-support-via-uart)を参照してください



#### 外部パーティションの暗号化サポート



`SPI_FLASH`、`UART_FLASH`、またはカスタム外部マッピングと組み合わせて、`EXT_FLASH=1`を使用して更新およびスワップパーティションが外部デバイスにマッピングされると、ブートローダからそれらのパーティションにアクセスするときにChacha20、AES128、またはAES256暗号化を有効にすることができます。更新イメージは、鍵ツールを使用して提供元で事前に暗号化する必要があります。wolfBootは、一時Chacha20対称鍵を使用して更新のコンテンツにアクセスするように指示する必要があります。


このオプション機能の詳細については、[暗号化された外部パーティション](chapter06.md#encrypted-external-partitions)セクションを参照してください。





### RAMからフラッシュアクセスコードの実行



wolfBootが実行されている同じデバイスに書き込むとき、またはフラッシュ自体の構成を変更するときなどに、一部のプラットフォームでは、Flash AccessコードをRAMから実行する必要があります。


ライティング用の内部フラッシュにアクセスするすべてのコードをRAMのセクションに移動するには、コンパイル時間オプション`RAM_CODE=1`を使用します(一部のハードウェア構成では、ブートローダーが書き込みのためにフラッシュにアクセスするために必要です)。



### デュアルバンクハードウェアアシストスワッピングの有効化



ターゲットプラットフォームでサポートされる場合、ハードウェアアシストデュアルバンクスワッピングを使用して更新を実行できます。この機能を有効にするには、`DUALBANK_SWAP=1`を使用してください。現在、STM32F76XとF77Xのみがこの機能をサポートしています。





### ブートパーティションセクターに更新パーティションフラグを保存



デフォルトでは、wolfBootは、各パーティションの最後にある特定のエリアの単一セクターへの更新手順のステータスを追跡し、パーティション自体に関連付けられたフラグのセットを保存および取得することに専念しています。


場合によっては、更新パーティションに関連するステータスフラグとそのセクターを内部フラッシュに保存すると、ブートパーティションに使用される同じフラグのセットとともに保存することが役立つ場合があります。`FLAGS_HOME=1` MakeFileオプションでwolfBootをコンパイルすることにより、更新パーティションに関連付けられたフラグがブートパーティション自体に保存されます。


一方では、このオプションはブートパーティションで使用可能なスペースをわずかに削減してファームウェアイメージを保存しますが、すべてのフラグをブートパーティションに保存します。



### フラグの反転ロジック

デフォルトでは、ほとんどのNVMSは、消去されたページのコンテンツを`0xFF`(すべて)に設定します。一部のフラッシュメモリモデルは、消去ページに反転したロジックを使用し、消去後にコンテンツを`0x00`(すべてゼロ)に設定します。これらの特別なケースでは、オプション`FLAGS_INVERT=1`を使用して、wolfBootで使用されるパーティション/セクターフラグのロジックを変更できます。


注：上記の`FLAGS_HOME=1`オプションを使用して、反転ロジックとフラッシュと組み合わせて外部フラッシュ(SPI)を使用している場合は、すべてのフラグを1つのパーティションに保存してください。





### Mac OS/Xの使用



Factory.binで0xc3 0xbf(C3BF)が繰り返されている場合、OSはUnicode文字を使用しています。


`"bootloader" ... 0xFF ... "application"=factory.bin`の間に0xffパディングを組み立てるための「TR」コマンド。「C」ロケールが必要です。


これを端末に設定します

```
LANG=
LC_COLLATE="C"
LC_CTYPE="C"
LC_MESSAGES="C"
LC_MONETARY="C"
LC_NUMERIC="C"
LC_TIME="C"
LC_ALL=
```



次に、通常の`make`ステップを実行します。



### グリッチとフォールトインジェクションに対する軽減策の有効化



安全なブートメカニズムに対する攻撃の1つのタイプは、強制電圧またはクロックアノマリー、または近距離での電磁干渉を介してCPUに障害を注入することにより、認証と検証のステップの実行をスキップすることです。


CPU命令をスキップすることを目的とした特定の攻撃からの追加保護は、`ARMOR=1`を使用して有効にできます。この機能は現在、ARM Cortex-Mターゲットでのみ利用可能です。

